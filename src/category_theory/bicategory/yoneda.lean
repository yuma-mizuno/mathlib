import category_theory.bicategory.equivalence
import category_theory.bicategory.opposites
import category_theory.bicategory.pseudonat_trans
import category_theory.bicategory.Cat

open category_theory

universes w v u

open category_theory.bicategory opposite

namespace category_theory

namespace bicategory

section

variables {B : Type u} [bicategory.{w v} B] (a b c d : B)

/--
Left composition of 1-morphisms as a functor.
-/
@[simps]
def lcomp : (a ‚ü∂ b) ‚•§ (b ‚ü∂ c) ‚•§ (a ‚ü∂ c) :=
{ obj := Œª f,
  { obj := Œª g, f ‚â´ g,
    map := Œª g h Œ∑, f ‚óÉ Œ∑ },
  map := Œª f g Œ∑, { app := Œª h, Œ∑ ‚ñπ h } }

/--
Right composition of 1-morphisms as a functor.
-/
@[simps]
def rcomp : (b ‚ü∂ c) ‚•§ (a ‚ü∂ b) ‚•§ (a ‚ü∂ c) :=
{ obj := Œª f,
  { obj := Œª g, g ‚â´ f,
    map := Œª g h Œ∑, Œ∑ ‚ñπ f },
  map := Œª f g Œ∑, { app := Œª h, h ‚óÉ Œ∑ } }

variables {a b c d}

/--
Left component of an associator as a natural isomorphism.
-/
@[simps]
def associator_nat_iso_left (a) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :
  (rcomp a _ _).obj g ‚ãô (rcomp a _ _).obj h
  ‚âÖ (rcomp a _ _).obj (g ‚â´ h) :=
nat_iso.of_components
  (Œª f, Œ±_ f g h)
  (by { intros, apply associator_naturality_left })

/--
Middle component of an associator as a natural isomorphism.
-/
@[simps]
def associator_nat_iso_middle (f : a ‚ü∂ b) (h : c ‚ü∂ d) :
  (lcomp _ _ c).obj f ‚ãô (rcomp a _ _).obj h
  ‚âÖ (rcomp b _ _).obj h ‚ãô (lcomp _ _ d).obj f :=
nat_iso.of_components
  (Œª g, Œ±_ f g h)
  (by { intros, apply associator_naturality_middle })

/--
Right component of an associator as a natural isomorphism.
-/
@[simps]
def associator_nat_iso_right (d) (f : a ‚ü∂ b) (g : b ‚ü∂ c) :
  (lcomp _ _ d).obj (f ‚â´ g)
  ‚âÖ (lcomp _ _ d).obj g ‚ãô (lcomp _ _ d).obj f :=
nat_iso.of_components
  (Œª h, Œ±_ f g h)
  (by { intros, apply associator_naturality_right })

/--
Left unitor as a natural isomorphism.
-/
@[simps]
def left_unitor_nat_iso (a b : B) : (lcomp _ _ b).obj (ùüô a) ‚âÖ ùü≠ (a ‚ü∂ b) :=
nat_iso.of_components
  (Œª f, Œª_ f)
  (by { intros, apply left_unitor_naturality })

/--
Right unitor as a natural isomorphism.
-/
@[simps]
def right_unitor_nat_iso (a b : B): (rcomp a _ _).obj (ùüô b) ‚âÖ ùü≠ (a ‚ü∂ b) :=
nat_iso.of_components
  (Œª f, œÅ_ f)
  (by { intros, apply right_unitor_naturality })

end

end bicategory

section

open bicategory

variables {B : Type u} [bicategory.{w v} B]

/--
The Yoneda embedding at the level of objects.
-/
@[simps]
def yoneda_map‚ÇÄ (a : B) : pseudofunctor B·µí·µñ Cat :=
{ map‚ÇÄ := Œª s, Cat.of ((unop s) ‚ü∂ a),
  map‚ÇÅ := Œª s t f, (lcomp (unop t) (unop s) a).obj f,
  map‚ÇÇ := Œª s t f g Œ≤, (lcomp (unop t) (unop s) a).map Œ≤,
  map‚ÇÅ_id   := Œª s, (left_unitor_nat_iso (unop s) a).symm,
  map‚ÇÅ_comp := Œª s t r p q, (associator_nat_iso_right a q p).symm,
  map‚ÇÅ_comp_naturality_left'  := by { intros, ext, apply associator_inv_naturality_middle },
  map‚ÇÅ_comp_naturality_right' := by { intros, ext, apply associator_inv_naturality_left },
  map‚ÇÇ_id'    := by { intros, ext, apply bicategory.whisker_right_id },
  map‚ÇÇ_comp'  := by { intros, ext, apply bicategory.whisker_right_comp },
  map‚ÇÇ_associator'  := by { intros, ext, dsimp, erw pentagon_inv, simpa },
  map‚ÇÇ_left_unitor'   := by { intros, ext, dsimp, erw triangle_assoc_comp_right, simp },
  map‚ÇÇ_right_unitor'  := by { intros, ext, dsimp, simp,
                                erw [iso.hom_inv_id_assoc, inv_hom_whisker_right] } }

/--
The Yoneda embedding at the level of 1-morphisms.
-/
@[simps]
def yoneda_map‚ÇÅ {a b : B} (f : a ‚ü∂ b) : pseudonat_trans (yoneda_map‚ÇÄ a) (yoneda_map‚ÇÄ b) :=
{ app := Œª s, (rcomp (unop s) a b).obj f,
  naturality := Œª _ _ _, associator_nat_iso_middle _ f,
  naturality_naturality' := by { intros, ext, apply associator_naturality_left },
  naturality_id' := by { intros, ext, dsimp, simpa },
  naturality_comp' := by { intros, ext, dsimp, simp, erw pentagon_hom_hom_inv_inv_hom, refl } }

/--
The Yoneda embedding at the level of 2-morphisms.
-/
@[simps]
def yoneda_map‚ÇÇ {a b : B} {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) :
  modification (yoneda_map‚ÇÅ f) (yoneda_map‚ÇÅ g) :=
{ app := Œª s,
  { app := Œª h, h ‚óÉ Œ∑,
    naturality' := by { intros, dsimp, rw whisker_exchange } },
  naturality' := by { intros, ext, dsimp, apply associator_naturality_right } }

/--
The Yoneda embedding as a pseudofunctor from `B` into 2-presheaves on `B`.
-/
@[simps]
def yoneda : pseudofunctor B (pseudofunctor B·µí·µñ Cat) :=
{ map‚ÇÄ := yoneda_map‚ÇÄ,
  map‚ÇÅ := Œª _ _, yoneda_map‚ÇÅ,
  map‚ÇÇ := Œª _ _ _ _, yoneda_map‚ÇÇ,
  map‚ÇÅ_id := Œª a, modification_iso.of_components
    (Œª s : B·µí·µñ, (right_unitor_nat_iso (unop s) a).symm)
    (by { intros, ext, dsimp, simp }),
  map‚ÇÅ_comp := Œª (a b c : B) (f : a ‚ü∂ b) (g : b ‚ü∂ c), modification_iso.of_components
    (Œª s : B·µí·µñ, associator_nat_iso_left (unop s) f g)
    (by { intros, ext, dsimp, simp [pentagon] }),
  map‚ÇÅ_comp_naturality_left'  := by { intros, ext, dsimp, apply associator_naturality_middle },
  map‚ÇÅ_comp_naturality_right' := by { intros, ext, dsimp, apply associator_naturality_right },
  map‚ÇÇ_id'    := by { intros, ext, dsimp, apply bicategory.whisker_left_id },
  map‚ÇÇ_comp'  := by { intros, ext, dsimp, apply bicategory.whisker_left_comp },
  map‚ÇÇ_associator'  := by { intros, ext, dsimp, simp [pentagon] },
  map‚ÇÇ_left_unitor'   := by { intros, ext, dsimp, simp [triangle] },
  map‚ÇÇ_right_unitor'  := by { intros, ext, dsimp, simp [right_unitor_comp_inv] } }

end

section
open bicategory

variables
{B : Type u} [bicategory.{u u} B] (F : pseudofunctor B·µí·µñ Cat.{u u})

@[simps]
def yoneda_lemma_hom : pseudonat_trans (yoneda.op.comp (yoneda_map‚ÇÄ F)) F :=
{ app := Œª a : B·µí·µñ,
  { obj := Œª œÉ, (œÉ.app a).obj (ùüô (unop a)),
    map := Œª œÉ œÑ (Œì : modification œÉ œÑ), (Œì.app a).app (ùüô (unop a)),
    map_id' := by { intros, refl },
    map_comp' := by { intros, refl } },
  naturality := Œª (a b : B·µí·µñ) (f : a ‚ü∂ b), nat_iso.of_components (Œª œÉ,
    (œÉ.app b).map_iso (Œª_ f)
    ‚â™‚â´ ((œÉ.app b).map_iso (œÅ_ f)).symm
    ‚â™‚â´ (œÉ.naturality f).app (ùüô (unop a)))
    begin
      intros œÉ œÑ Œì,
      dsimp, simp only [category.assoc],
      have naturality := congr_app (modification.naturality Œì f) (ùüô (unop a)),
      dsimp at naturality,
      rw [‚Üênaturality, nat_trans.naturality_assoc, nat_trans.naturality_assoc]
    end,
  naturality_naturality' := Œª (a b : B·µí·µñ) (f g : a ‚ü∂ b) (Œ∑ : f ‚ü∂ g),
  begin
    ext œÉ,
    dsimp, simp only [category.assoc],
    have naturality := congr_app (œÉ.naturality_naturality Œ∑) (ùüô (unop a)),
    dsimp at naturality, rw [‚Üênaturality],
    simp only [‚Üêfunctor.map_comp_assoc],
    erw [left_unitor_naturality_assoc, left_unitor_inv_naturality],
    refl
  end,
  naturality_id' := Œª a : B·µí·µñ,
  begin
    ext œÉ, dsimp, simp,
    have naturality := congr_app (œÉ.naturality_id a) (ùüô _),
    dsimp at naturality, simp only [category.id_comp] at naturality,
    simp only [‚Üêfunctor.map_comp_assoc],
    erw [unitors_equal, iso.inv_hom_id_assoc, ‚Üêunitors_inv_equal, naturality]
  end,
  naturality_comp' := Œª (a b c : B·µí·µñ) (f : a ‚ü∂ b) (g : b ‚ü∂ c),
  begin
    ext œÉ, dsimp, simp,
    have naturality := congr_app (œÉ.naturality_comp f g) (ùüô _),
    dsimp at naturality, simp only [category_theory.category.id_comp] at naturality,
    simp only [‚Üêfunctor.map_comp_assoc],
    erw [left_unitor_comp_assoc, iso.hom_inv_id_assoc, right_unitor_comp_inv,
    triangle_assoc_comp_right_inv],
    simp only [category_theory.category.assoc, category_theory.functor.map_comp],
    rw naturality,
    erw ‚Üênat_trans.naturality_assoc,
    erw ‚Üênat_trans.naturality_assoc,
    dsimp,
    simp only [‚Üêfunctor.map_comp_assoc],
    erw [inv_hom_whisker_left_assoc],
  end }

variables {F}

@[simps]
def yoneda_lemma_inv_pseudonat_trans {a : B·µí·µñ} (u : F.map‚ÇÄ a) :
  pseudonat_trans (yoneda_map‚ÇÄ (unop a)) F :=
{ app := Œª s : B·µí·µñ,
  { obj := Œª g : a ‚ü∂ s, (F.map‚ÇÅ g).obj u,
    map := Œª (g h : a ‚ü∂ s) (Œ≤ : g ‚ü∂ h), (F.map‚ÇÇ Œ≤).app u,
    map_id'     := by { intros, rw [F.map‚ÇÇ_id, nat_trans.id_app] },
    map_comp'   := by { intros, rw [F.map‚ÇÇ_comp, nat_trans.comp_app] } },
  naturality := Œª (s t : B·µí·µñ) (p : s ‚ü∂ t), nat_iso.of_components
    (Œª g : a ‚ü∂ s, ((F.map‚ÇÅ_comp g p).app u).symm)
    (Œª (g h : a ‚ü∂ s) (Œ≤ : g ‚ü∂ h), by
    { dsimp, simp only [‚Üêwhisker_right_app, ‚Üênat_trans.comp_app],
      erw F.map‚ÇÅ_comp_inv_naturality_left, refl }),
  naturality_naturality' := Œª (s t : B·µí·µñ) (p q : s ‚ü∂ t) (Œ≤ : p ‚ü∂ q), by
  { ext (g : a ‚ü∂ s),
    dsimp, simp only [‚Üêwhisker_left_app, ‚Üênat_trans.comp_app],
    erw F.map‚ÇÅ_comp_inv_naturality_right, refl },
  naturality_id' := Œª s : B·µí·µñ, by
  { ext (g : a ‚ü∂ s),
    dsimp, simp only [category.id_comp, ‚Üêwhisker_left_app, ‚Üênat_trans.comp_app],
    erw [F.map‚ÇÇ_right_unitor_inv_eq_assoc, iso.hom_inv_id], dsimp, simp },
  naturality_comp' := Œª (s t r : B·µí·µñ) (p : s ‚ü∂ t) (q : t ‚ü∂ r), by
  { ext (g : a ‚ü∂ s), dsimp,
    simp only [category.id_comp, ‚Üêwhisker_left_app, ‚Üêwhisker_right_app, ‚Üênat_trans.comp_app],
    erw F.map‚ÇÇ_associator_eq_assoc, dsimp, simp, erw category.comp_id, refl } }

@[simps]
def yoneda_lemma_inv_modification {a : B·µí·µñ} {u v : F.map‚ÇÄ a} (k : u ‚ü∂ v) :
  modification (yoneda_lemma_inv_pseudonat_trans u) (yoneda_lemma_inv_pseudonat_trans v) :=
{ app := Œª s : B·µí·µñ,
  { app := Œª g : a ‚ü∂ s, (F.map‚ÇÅ g).map k,
    naturality' := by { intros, dsimp, rw nat_trans.naturality } },
  naturality' := by { intros, ext, dsimp, rw nat_trans.naturality, refl } }

@[simps]
def yoneda_lemma_inv_functor (a : B·µí·µñ) : F.map‚ÇÄ a ‚•§ pseudonat_trans (yoneda_map‚ÇÄ (unop a)) F :=
{ obj := Œª u : F.map‚ÇÄ a, yoneda_lemma_inv_pseudonat_trans u,
  map := Œª (u v : F.map‚ÇÄ a) (k : u ‚ü∂ v), yoneda_lemma_inv_modification k,
  map_id'     := by { intros, ext, dsimp, rw functor.map_id },
  map_comp'   := by { intros, ext, dsimp, rw functor.map_comp } }

@[simps]
def yoneda_lemma_inv_iso {a b : B·µí·µñ} (f : a ‚ü∂ b) (u : F.map‚ÇÄ a) :
  ((yoneda.op.comp (yoneda_map‚ÇÄ F)).map‚ÇÅ f).obj (yoneda_lemma_inv_pseudonat_trans u) ‚âÖ
    yoneda_lemma_inv_pseudonat_trans ((F.map‚ÇÅ f).obj u) := by
{ apply modification_iso.of_components (Œª s : B·µí·µñ, _) _,
  apply nat_iso.of_components (Œª g : b ‚ü∂ s, _) _,
  apply iso.app (F.map‚ÇÅ_comp f g).symm u,
  { intros g h Œ≤, dsimp, simp only [‚Üêwhisker_left_app, ‚Üênat_trans.comp_app],
    erw F.map‚ÇÅ_comp_inv_naturality_right, refl },
  { intros s t p, ext (g : b ‚ü∂ s),
    dsimp, simp,
    simp only [‚Üêwhisker_left_app, ‚Üêwhisker_right_app, ‚Üênat_trans.comp_app],
    erw [F.map‚ÇÇ_associator_inv_eq_assoc, iso.hom_inv_id_assoc],
    dsimp, simp only [‚Üêfunctor.map_comp, ‚Üênat_trans.comp_app],
    erw [iso.hom_inv_id, functor.map_id], simp, refl } }

variables (F)

section aux
variables {a b c : B·µí·µñ}

lemma yoneda_lemma_inv_aux‚ÇÅ (f : unop b ‚ü∂ unop a) (u : F.map‚ÇÄ a)
  {s : B·µí·µñ} {g h : unop s ‚ü∂ unop b} (Œ≤ : g ‚ü∂ h) :
  (((yoneda_lemma_inv_functor b).obj ((F.map‚ÇÅ f).obj u)).app s).map Œ≤ ‚â´
      (F.map‚ÇÅ_comp f h).hom.app u =
    (F.map‚ÇÅ_comp f g).hom.app u ‚â´
      (((yoneda_lemma_inv_functor a).obj u).app s).map (Œ≤ ‚ñπ f) :=
begin
  dsimp [yoneda_lemma_inv_functor], simp only [‚Üêwhisker_left_app, ‚Üênat_trans.comp_app],
  erw F.map‚ÇÅ_comp_naturality_right, refl,
end

lemma yoneda_lemma_inv_aux‚ÇÇ (f : unop b ‚ü∂ unop a) (u : F.map‚ÇÄ a)
  {s t : B·µí·µñ} (p : unop t ‚ü∂ unop s) (g : unop s ‚ü∂ unop b) :
(F.map‚ÇÅ_comp f (g ‚â´ p)).hom.app u ‚â´
  ((((yoneda.op.comp (yoneda_map‚ÇÄ F)).map‚ÇÅ f).obj ((yoneda_lemma_inv_functor a).obj u)).naturality p).hom.app g
  = (((yoneda_lemma_inv_functor b).obj ((F.map‚ÇÅ f).obj u)).naturality p).hom.app g ‚â´
      (F.map‚ÇÅ p).map ((F.map‚ÇÅ_comp f g).hom.app u) :=
begin
  dsimp [yoneda_lemma_inv_functor], simp,
  simp only [‚Üêwhisker_left_app, ‚Üêwhisker_right_app, ‚Üênat_trans.comp_app],
  erw [F.map‚ÇÇ_associator_inv_eq_assoc, iso.hom_inv_id_assoc,
      iso.hom_inv_id, category.comp_id],
  simp, erw category.id_comp
end

lemma yoneda_lemma_inv_aux‚ÇÉ (f : unop b ‚ü∂ unop a) {u v : F.map‚ÇÄ a}
  (k : u ‚ü∂ v) {s : B·µí·µñ} (g : b ‚ü∂ s) :
(((yoneda_lemma_inv_functor b).map ((F.map‚ÇÅ f).map k)).app s).app g ‚â´
  (F.map‚ÇÅ_comp f g).hom.app v
  = (F.map‚ÇÅ_comp f g).hom.app u ‚â´
      (((yoneda_lemma_inv_functor a).map k).app s).app (g ‚â´ f) :=
begin
  erw ‚Üênat_trans.naturality, refl
end

lemma yoneda_lemma_inv_aux‚ÇÑ (f g : unop b ‚ü∂ unop a) (Œ≤ : f ‚ü∂ g) (u : F.map‚ÇÄ a)
  {s : B·µí·µñ} (h : unop s ‚ü∂ unop b) :
(((yoneda_lemma_inv_functor b).map ((F.map‚ÇÇ Œ≤).app u)).app s).app h ‚â´
  (F.map‚ÇÅ_comp g h).hom.app u
  = (F.map‚ÇÅ_comp f h).hom.app u ‚â´
      (((yoneda_lemma_inv_functor a).obj u).app s).map (h ‚óÉ Œ≤) :=
begin
  dsimp [yoneda_lemma_inv_functor],
  simp only [‚Üêwhisker_right_app, ‚Üênat_trans.comp_app],
  erw F.map‚ÇÅ_comp_naturality_left, refl
end

lemma yoneda_lemma_inv_aux‚ÇÖ (u : F.map‚ÇÄ a) {s : B·µí·µñ} (g : unop s ‚ü∂ unop a) :
(((yoneda_lemma_inv_functor a).map ((F.map‚ÇÅ_id a).hom.app u)).app s).app g ‚â´
  (F.map‚ÇÅ_comp (ùüô a) g).hom.app u
  = ùüô _ ‚â´ ùüô _ ‚â´
    ((((yoneda.op.comp (yoneda_map‚ÇÄ F)).map‚ÇÅ_id a).hom.app
      ((yoneda_lemma_inv_functor a).obj u)).app s).app g :=
begin
dsimp [yoneda_lemma_inv_functor],simp,
    simp only [‚Üêwhisker_left_app, ‚Üêwhisker_right_app, ‚Üênat_trans.comp_app],
    erw F.map‚ÇÇ_left_unitor_inv_eq,
    dsimp, erw category.id_comp, refl
end

lemma yoneda_lemma_inv_aux‚ÇÜ (f : unop b ‚ü∂ unop a) (g : unop c ‚ü∂ unop b)
  (u : F.map‚ÇÄ a) {s : B·µí·µñ} (h : unop s ‚ü∂ unop c) :
(((yoneda_lemma_inv_functor c).map ((F.map‚ÇÅ_comp f g).hom.app u)).app s).app h ‚â´
  (F.map‚ÇÅ_comp (f ‚â´ g) h).hom.app u
= ùüô _ ‚â´ (F.map‚ÇÅ_comp g h).hom.app ((F.map‚ÇÅ f).obj u) ‚â´
    ùüô _ ‚â´ (F.map‚ÇÅ_comp f (g ‚â´ h)).hom.app u ‚â´
      ùüô _ ‚â´ ((((yoneda.op.comp (yoneda_map‚ÇÄ F)).map‚ÇÅ_comp f g).hom.app
                ((yoneda_lemma_inv_functor a).obj u)).app s).app h :=
begin
  dsimp [yoneda_lemma_inv_functor], simp,
  simp only [‚Üêwhisker_left_app, ‚Üêwhisker_right_app, ‚Üênat_trans.comp_app],
  erw [F.map‚ÇÇ_associator_inv_eq, iso.hom_inv_id_assoc], simp,
  erw category.id_comp
end

end aux

@[simps]
def yoneda_lemma_inv : pseudonat_trans F (yoneda.op.comp (yoneda_map‚ÇÄ F)) :=
{ app := Œª a : B·µí·µñ, yoneda_lemma_inv_functor a,
  naturality := Œª (a b : B·µí·µñ) (f : a ‚ü∂ b), by
  { apply nat_iso.of_components (Œª u : F.map‚ÇÄ a, _) _,
    apply modification_iso.of_components (Œª s : B·µí·µñ, _) _,
    apply nat_iso.of_components (Œª g : b ‚ü∂ s, _) _,
    apply iso.app (F.map‚ÇÅ_comp f g) u,
    { intros, dsimp only [], apply yoneda_lemma_inv_aux‚ÇÅ },
    { intros, ext, apply yoneda_lemma_inv_aux‚ÇÇ },
    { intros, ext, apply yoneda_lemma_inv_aux‚ÇÉ } },
  naturality_naturality' := by { intros, ext, apply yoneda_lemma_inv_aux‚ÇÑ },
  naturality_id' := by { intros, ext, apply yoneda_lemma_inv_aux‚ÇÖ },
  naturality_comp' := by { intros, ext, apply yoneda_lemma_inv_aux‚ÇÜ } }

section aux
variables {a b : B·µí·µñ} (f : unop b ‚ü∂ unop a)
(œÉ : pseudonat_trans (yoneda_map‚ÇÄ (unop a)) F)


lemma yoneda_lemma_aux‚ÇÅ {s : B·µí·µñ} {g h : unop s ‚ü∂ unop a} (Œ≤ : g ‚ü∂ h) :
  (œÉ.app s).map Œ≤ ‚â´ (œÉ.app s).map (œÅ_ h).inv ‚â´ (œÉ.naturality h).hom.app (ùüô (unop a))
  = ((œÉ.app s).map (œÅ_ g).inv ‚â´ (œÉ.naturality g).hom.app (ùüô (unop a))) ‚â´
      ((((yoneda_lemma_inv F).app a).obj (((yoneda_lemma_hom F).app a).obj œÉ)).app s).map Œ≤ :=
begin
  dsimp, simp only [‚Üêfunctor.map_comp_assoc],
  rw right_unitor_inv_naturality,
  simp,
  have naturality := nat_trans.congr_app (œÉ.naturality_naturality Œ≤) (ùüô _),
  dsimp at naturality,
  simp only [‚Üêwhisker_left_app, ‚Üêwhisker_right_app, ‚Üênat_trans.comp_app,
    ‚Üêfunctor.map_comp],
  erw naturality, refl
end

lemma yoneda_lemma_aux‚ÇÇ {s t : B·µí·µñ} (p : unop t ‚ü∂ unop s) (g : unop s ‚ü∂ unop a) :
((œÉ.app t).map (œÅ_ (p ‚â´ g)).inv ‚â´ (œÉ.naturality (g ‚â´ p)).hom.app (ùüô (unop a))) ‚â´
  ((((yoneda_lemma_inv F).app a).obj
    (((yoneda_lemma_hom F).app a).obj œÉ)).naturality p).hom.app g
= (œÉ.naturality p).hom.app g ‚â´ (F.map‚ÇÅ p).map ((œÉ.app s).map (œÅ_ g).inv ‚â´
    (œÉ.naturality g).hom.app (ùüô (unop a))) :=
begin
  dsimp, simp,
  have comp := nat_trans.congr_app (œÉ.naturality_comp g p) (ùüô (unop a)),
  have naturality := ((œÉ.naturality p).hom.naturality _),
  dsimp at comp naturality, simp at comp,
  slice_rhs 1 2 { erw ‚Üênaturality },
  slice_lhs 2 3 { erw comp },
  simp, erw category.comp_id
end

lemma yoneda_lemma_aux‚ÇÉ {œÉ œÑ : pseudonat_trans (yoneda_map‚ÇÄ (unop a)) F}
  (Œ¶ : œÉ ‚ü∂ œÑ) {s : B·µí·µñ} (g : unop s ‚ü∂ unop a) :
(Œ¶.app s).app g ‚â´ (œÑ.app s).map (œÅ_ g).inv ‚â´ (œÑ.naturality g).hom.app (ùüô (unop a))
= ((œÉ.app s).map (œÅ_ g).inv ‚â´ (œÉ.naturality g).hom.app (ùüô (unop a))) ‚â´
    ((((yoneda_lemma_inv F).app a).map (((yoneda_lemma_hom F).app a).map Œ¶)).app s).app g :=
begin
  dsimp, simp,
  erw ‚Üênat_trans.naturality_assoc,
  have naturality := nat_trans.congr_app (Œ¶.naturality g) (ùüô _),
  dsimp at naturality,
  erw naturality
end

lemma yoneda_lemma_aux‚ÇÑ {s : B·µí·µñ} (g : unop s ‚ü∂ unop b) :
((œÉ.app s).map ((œÅ_ g).inv ‚ñπ f) ‚â´
  ((((yoneda.op.comp (yoneda_map‚ÇÄ F)).map‚ÇÅ f).obj œÉ).naturality g).hom.app (ùüô (unop b))) ‚â´ ùüô _ ‚â´
    ((((yoneda_lemma_inv F).app b).map
      (((yoneda_lemma_hom F).naturality f).hom.app œÉ)).app s).app g ‚â´ ùüô _ ‚â´
        ((((yoneda_lemma_inv F).naturality f).hom.app
          (((yoneda_lemma_hom F).app a).obj œÉ)).app s).app g ‚â´ ùüô _
= (ùüô _ ‚â´ ùüô _) ‚â´
    (œÉ.app s).map (œÅ_ (g ‚â´ f)).inv ‚â´
      (œÉ.naturality (f ‚â´ g)).hom.app (ùüô (unop a)) :=
begin
  dsimp, simp,
  have comp := nat_trans.congr_app (œÉ.naturality_comp f g) (ùüô (unop a)),
  dsimp at comp, simp at comp,
  erw comp,
  simp only [‚Üêcategory.assoc], congr' 2, simp only [category.assoc],
  simp only [‚Üêfunctor.map_comp],
  erw ‚Üênat_trans.naturality,
  simp,
  simp only [‚Üêfunctor.map_comp_assoc],
  erw triangle_assoc,
  simp
end

lemma yoneda_lemma_aux‚ÇÖ {u v : F.map‚ÇÄ a} (k :u ‚ü∂ v) :
((yoneda_lemma_hom F).app a).map (((yoneda_lemma_inv F).app a).map k) ‚â´ (F.map‚ÇÅ_id a).inv.app v
= (F.map‚ÇÅ_id a).inv.app u ‚â´ k :=
begin
  dsimp,
  simp [nat_trans.naturality]
end

lemma yoneda_lemma_aux‚ÇÜ (f : unop b ‚ü∂ unop a) (u : F.map‚ÇÄ a) :
(F.map‚ÇÅ_id b).inv.app ((F.map‚ÇÅ f).obj u) ‚â´ ùüô _ ‚â´ ùüô _
= (ùüô _ ‚â´
  ((yoneda_lemma_hom F).app b).map
    (((yoneda_lemma_inv F).naturality f).hom.app u) ‚â´ ùüô _ ‚â´
      ((yoneda_lemma_hom F).naturality f).hom.app
        (((yoneda_lemma_inv F).app a).obj u) ‚â´ ùüô _) ‚â´
          (F.map‚ÇÅ f).map ((F.map‚ÇÅ_id a).inv.app u) :=
begin
  dsimp, simp,
  simp only [‚Üêwhisker_left_app, ‚Üêwhisker_right_app, ‚Üênat_trans.comp_app],
  erw [F.map‚ÇÇ_left_unitor_inv_eq_assoc, F.map‚ÇÇ_right_unitor_eq_assoc,
      iso.hom_inv_id_assoc, iso.hom_inv_id_assoc, iso.hom_inv_id_assoc],
  simp, simp only [‚Üêfunctor.map_comp, ‚Üênat_trans.comp_app],
  erw iso.hom_inv_id,
  simp,
  erw category.comp_id
end

end aux

/--
The Yoneda lemma. It is a equivalence between `yoneda.op.comp (yoneda_map‚ÇÄ F)` and `F` in
the bicategory `pseudofunctor B·µí·µñ Cat`.
-/
def yoneda_lemma : bicategory.equivalence (yoneda.op.comp (yoneda_map‚ÇÄ F)) F :=
{ hom := yoneda_lemma_hom F,
  inv := yoneda_lemma_inv F,
  unit_iso := by
  { apply modification_iso.of_components (Œª a : B·µí·µñ, _) _,
    apply nat_iso.of_components (Œª œÉ : pseudonat_trans (yoneda_map‚ÇÄ (unop a)) F, _) _,
    apply modification_iso.of_components (Œª s : B·µí·µñ, _) _,
    apply nat_iso.of_components (Œª g : a ‚ü∂ s, _) _,
    exact (œÉ.app s).map_iso (Œª_ g).symm ‚â™‚â´ ((œÉ.naturality g).app (ùüô (unop a))),
    { intros, dsimp only [], apply yoneda_lemma_aux‚ÇÅ, },
    { intros, ext, apply yoneda_lemma_aux‚ÇÇ },
    { intros, ext, apply yoneda_lemma_aux‚ÇÉ },
    { intros, ext, apply yoneda_lemma_aux‚ÇÑ } },
  counit_iso := by
  { apply modification_iso.of_components (Œª a : B·µí·µñ, _) _,
    apply nat_iso.of_components (Œª u : F.map‚ÇÄ a, _) _,
    exact (F.map‚ÇÅ_id a).symm.app u,
    { intros, dsimp only [], apply yoneda_lemma_aux‚ÇÖ },
    { intros, ext, apply yoneda_lemma_aux‚ÇÜ } } }

end

end category_theory
